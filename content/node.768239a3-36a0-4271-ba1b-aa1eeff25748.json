{
    "uuid": [
        {
            "value": "768239a3-36a0-4271-ba1b-aa1eeff25748"
        }
    ],
    "langcode": [
        {
            "value": "en"
        }
    ],
    "type": [
        {
            "target_id": "blog",
            "target_type": "node_type",
            "target_uuid": "a90c00e7-fd49-42a6-8cdb-e99ec16f7742"
        }
    ],
    "revision_timestamp": [
        {
            "value": "2021-08-10T03:59:11+00:00",
            "format": "Y-m-d\\TH:i:sP"
        }
    ],
    "revision_uid": [
        {
            "target_type": "user",
            "target_uuid": "30bffdc0-96b3-4656-9078-3f8113359c60"
        }
    ],
    "revision_log": [],
    "status": [
        {
            "value": true
        }
    ],
    "uid": [
        {
            "target_type": "user",
            "target_uuid": "30bffdc0-96b3-4656-9078-3f8113359c60"
        }
    ],
    "title": [
        {
            "value": "Making a multi-track tape recorder for MIDI in JavaScript"
        }
    ],
    "created": [
        {
            "value": "2021-08-08T20:28:00+00:00",
            "format": "Y-m-d\\TH:i:sP"
        }
    ],
    "changed": [
        {
            "value": "2021-08-10T03:59:11+00:00",
            "format": "Y-m-d\\TH:i:sP"
        }
    ],
    "promote": [
        {
            "value": true
        }
    ],
    "sticky": [
        {
            "value": false
        }
    ],
    "default_langcode": [
        {
            "value": true
        }
    ],
    "revision_translation_affected": [
        {
            "value": true
        }
    ],
    "path": [
        {
            "alias": "\/blog\/making-multi-track-tape-recorder-midi-javascript",
            "langcode": "en",
            "pathauto": 1
        }
    ],
    "body": [
        {
            "value": "<p>During quarantine I decided to start playing music again, and entered the world of synthesizers, \"DAWless\" setups, and inevitably MIDI. I currently have a Keystep 37, Roland MC-101, and Elektron Model:Cycles. The latter two devices are \"grooveboxes\" - standalone hardware that let you make music and live jam without a computer. They have different workflows, but in both you work mostly in sequences which let you compose in 4 or 8 bars at a time.<\/p>\r\n\r\n<p>People who are good at playing live can make 4 bars last a long time - introducing instruments one at a time, modifying tones as they play, and muting\/un-muting&nbsp;instruments are all techniques to keep a set going. I'm not much of a live performer - I prefer to make linear songs, with melodies that extend beyond the limits of my grooveboxes.<\/p>\r\n\r\n<p>If you don't want to use the built-in sequencing of your devices, you're probably going to use a DAW to manage multiple&nbsp;MIDI tracks that send messages to your external devices to play notes. There are a lot of DAWs with good MIDI support, but a goal for me with my setup is to get away from a computer based workflow. I really wanted to sit down, start recording, and build up tracks with live recording instead of clicking notes on a keyboard roll. You can live record MIDI in these DAWs too, but it's cumbersome to set up the tracks and MIDI routing to get everything working, and I found the workflow for making quick edits to a track to be difficult.<\/p>\r\n\r\n<p>When I searched for something similar, I kept coming back to&nbsp;4-track tape recorders, which allow you to record multiple tracks to a&nbsp;cassette or reel-to-reel&nbsp;tape.<\/p>\r\n<img alt=\"A Tascam PortaStudio, a 4-track cassette recorder\" data-caption=\"&lt;em&gt;A Tascam PortaStudio, photo credit to&amp;nbsp;&lt;a href=&quot;https:\/\/commons.wikimedia.org\/wiki\/File:Tascam_PortaStudio_424_MKII_crop.jpg&quot;&gt;CountrySkyStudio&lt;\/a&gt;.&lt;\/em&gt;\" data-entity-type=\"file\" data-entity-uuid=\"4381eca3-7805-4aba-a677-fb083fdad2f5\" height=\"571\" src=\"\/sites\/default\/files\/inline-images\/Tascam_PortaStudio_424_MKII_crop.jpg\" width=\"636\" \/>\r\n<p>While limited, they're extremely easy to use. Press play, press record, and jam directly to tape. Famously The Beatles'&nbsp;Sgt. Pepper's Lonely Hearts Club Band was recorded entirely on 4-track, although that may have been more about the technology available at the time than the accessibility of using them. Anyway, I wanted a similar experience for MIDI - plug in my keyboard controller and my devices, press record, and jam without being slowed down by a DAW.<\/p>\r\n\r\n<p>A&nbsp;modern take on this, and the closest user experience to what I wanted, is the Teenage Engineering OP-1's \"tape mode\" feature. In tape mode, you get one infinitely long tape where you can record your tracks live. I don't own an OP-1, but had watched enough videos about it to know that this was close to the experience I wanted for MIDI.<\/p>\r\n\r\n<p>[insert op-1 tape mode image or gif here]<\/p>\r\n\r\n<p>So, I got to work and created midi-tape, a web-based tape mode style recording software for external MIDI devices. Among other things I used the Web MIDI API, Web Audio API, and MediaRecorder API to power it, which was a good stress test of what a browser is capable of. If you have a few synths and a MIDI controller laying around, I encourage you to try it out!<\/p>\r\n\r\n<p>[insert midi-tape gif here]<\/p>\r\n\r\n<p>I've done a few write ups of recent projects, but most are more narrative&nbsp;based and less about code. This time around I want to focus on how it works and give concrete examples of how I worked through issues instead, so if that interests&nbsp;you please keep reading!<\/p>\r\n\r\n<h2>Using Web MIDI to receive and send messages<\/h2>\r\n\r\n<p>One major reason I decided to make this a web app and not a local&nbsp;executable was that the <a href=\"https:\/\/www.w3.org\/TR\/webmidi\/\">Web MIDI API<\/a> is really good. It's one of the few APIs I've seen&nbsp;added that is basically fully featured, and one of the only ones I know of that allows you to control external devices (the <a href=\"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/WebUSB_API\">WebUSB<\/a>&nbsp;and <a href=\"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/Web_Serial_API\">Web Serial API<\/a> will make this more common, I guess).<\/p>\r\n\r\n<p>To make Web MIDI more usable, I started using a wrapper library, <a href=\"https:\/\/github.com\/djipco\/webmidi\">djipco\/webmidi<\/a>. Using webmidi, I was able to read input from my MIDI controllers:<\/p>\r\n\r\n<p><br \/>\r\n<code>WebMidi.enable((err) =&gt; {<br \/>\r\n&nbsp;&nbsp;WebMidi.inputs.forEach(function (input, key) {<br \/>\r\n&nbsp;&nbsp;&nbsp;&nbsp;addInputListeners(input);<br \/>\r\n&nbsp;&nbsp;});<br \/>\r\n&nbsp;&nbsp;WebMidi.addListener(\"connected\", function (e) {<br \/>\r\n&nbsp;&nbsp;&nbsp;&nbsp;if (e.port.type === \"input\") {<br \/>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addInputListeners(e.port);<br \/>\r\n&nbsp;&nbsp;&nbsp;&nbsp;}<br \/>\r\n&nbsp;&nbsp;&nbsp;&nbsp;setDevicesByName();<br \/>\r\n&nbsp;&nbsp;});<br \/>\r\n&nbsp;&nbsp;WebMidi.addListener(\"disconnected\", function (e) {<br \/>\r\n&nbsp;&nbsp;&nbsp;&nbsp;setDevicesByName();<br \/>\r\n&nbsp;&nbsp;});<br \/>\r\n});<br \/>\r\nfunction addInputListeners(input) {<br \/>\r\n&nbsp;&nbsp;input.removeListener(\"noteon\");<br \/>\r\n&nbsp;&nbsp;input.removeListener(\"noteoff\");<br \/>\r\n&nbsp;&nbsp;input.removeListener(\"pitchbend\");<br \/>\r\n&nbsp;&nbsp;input.removeListener(\"controlchange\");<br \/>\r\n&nbsp;&nbsp;input.addListener(\"noteon\", \"all\", onNoteOn);<br \/>\r\n&nbsp;&nbsp;input.addListener(\"noteoff\", \"all\", onNoteOff);<br \/>\r\n&nbsp;&nbsp;input.addListener(\"pitchbend\", \"all\", onPitchBend);<br \/>\r\n&nbsp;&nbsp;input.addListener(\"controlchange\", \"all\", onControlChange);<br \/>\r\n}<\/code><\/p>\r\n\r\n<p>In the above code sample, I initialize the Web MIDI API, attach event listeners for all the existing inputs, and then set up listeners to handle newly connected\/disconnected devices. The real event handlers are quite complex, but here's a simplified \"onNoteOn\" which passes all noteOn events to an arbitrary output device:<\/p>\r\n\r\n<p><code>function onNoteOn(event) {<br \/>\r\n&nbsp;&nbsp;WebMidi.outputs[0].playNote(<br \/>\r\n&nbsp; &nbsp; \/\/ You could also use event.note.number but this is better for debugging.<br \/>\r\n&nbsp; &nbsp; event.note.name + event.note.octave,<br \/>\r\n&nbsp; &nbsp; event.channel,<br \/>\r\n&nbsp; &nbsp; {<br \/>\r\n&nbsp; &nbsp; &nbsp; velocity: event.velocity,<br \/>\r\n&nbsp; &nbsp; }<br \/>\r\n&nbsp; );<br \/>\r\n}<\/code><\/p>\r\n\r\n<p>With a bit of a user interface to select input\/output devices and channels, the code above would be enough to use your browser as a lightweight MIDI interface, which is pretty useful on its own.<\/p>\r\n\r\n<p>In the real midi-tape code, there's a global variable that tracks the current input device, and all event handlers only handle events from that device. The output device is determined by the currently selected&nbsp;track. The global variable&nbsp;looks something like this:<\/p>\r\n\r\n<p><code>let tape = {<br \/>\r\n&nbsp;&nbsp;inputDevice: 0,<br \/>\r\n&nbsp;&nbsp;inputDeviceName: \"My keyboard\",<br \/>\r\n&nbsp;&nbsp;tracks: [<br \/>\r\n&nbsp;&nbsp;&nbsp;&nbsp;outputDevice: 1,<br \/>\r\n&nbsp;&nbsp;&nbsp;&nbsp;outputDeviceName: \"My synth\",<br \/>\r\n&nbsp;&nbsp;&nbsp;&nbsp;outputChannel: 5,<br \/>\r\n&nbsp;&nbsp;],<br \/>\r\n};<\/code><\/p>\r\n\r\n<p>You'll notice that the devices are referenced both by index and name - this allows for devices to be connected and disconnected at any time without the user having to re-configure mappings. The \"setDevicesByName()\" method referenced earlier is called anytime the devices change to enable this behavior.<\/p>\r\n\r\n<p>This is about it for how MIDI messages are handled, but I wanted to call out a problem that I had throughout development - unfinished noteOn&nbsp;events. Imagine you're using the code above, press a key down on your keyboard, then disconnect that keyboard. Your synth would get a noteOn message but never get a noteOff message. This was pretty annoying, so I made a utility function to stop all notes on all devices:<br \/>\r\n<br \/>\r\n<code>function stopAllNotes() {<br \/>\r\n&nbsp; getOutputs().forEach(function (output) {<br \/>\r\n&nbsp; &nbsp; output.stopNote(\"all\");<br \/>\r\n&nbsp; });<br \/>\r\n&nbsp; tape.tracks.forEach(function (track, trackNumber) {<br \/>\r\n&nbsp; &nbsp; getOutputDevice(trackNumber).sendPitchBend(0);<br \/>\r\n&nbsp; });<br \/>\r\n&nbsp; for (let key in justNoteOn) {<br \/>\r\n&nbsp; &nbsp; let parts = key.split(\":\"); \/\/ ex: 0:C4<br \/>\r\n&nbsp; &nbsp; getOutputDevice(parts[0]).stopNote(parts[1]);<br \/>\r\n&nbsp; }<br \/>\r\n&nbsp; justNoteOn = {};<br \/>\r\n}<\/code><\/p>\r\n\r\n<p>I haven't edited this snippet from the original code - but know that \"getOutputs\" and \"getOutputDevice\" are just wrappers that allow for fake devices and error handling. \"output.stopNote(\"all\")\" sends a \"All Notes Off\" MIDI CC (controller change) message, but I found that not all devices respect this, so I also had to add a global \"justNoteOn\" variable which tracks all unfinished notes for all output devices. I wanted to call this out as an example of how implementing MIDI isn't as simple as doing things the right way, not all devices are the same and not all share the same support for different \"standard\" CC messages.<\/p>\r\n\r\n<h2>Recording and making an accurate timer in JavaScript<\/h2>\r\n\r\n<p>Now that MIDI was set up, it was time to actually record and playback messages. My first big decision&nbsp;was to&nbsp;store data based on a current \"step\" instead of by time. The MIDI file format, and how you send things like the clock to devices, is very tied to steps so I figured this would be easier than time. In MIDI, there's a concept called parts per quarter note or PPQ - this is the resolution that MIDI is stored in. The higher the PPQ, the more accurate the recording is.&nbsp;In a modern DAW this number could be extremely high, but on older sequencers it's typically in the 24 to 96 PPQ range. I designed the \"main\" loop of my code to be called once per step, but performance wise this was probably not wise&nbsp;as I was forced to lower my PPQ down to 24 to maintain consistent performance.<\/p>\r\n\r\n<p>Let's look at what that main callback looks like and talk about timers in JavaScript. Here's a simplified code sample showing how notes are stored, and how they're played back every step:<\/p>\r\n\r\n<p><br \/>\r\n<code>let tape = {<br \/>\r\n&nbsp; ppq: 24,<br \/>\r\n&nbsp; bpm: 110,<br \/>\r\n&nbsp; tracks: [<br \/>\r\n&nbsp; &nbsp; {<br \/>\r\n&nbsp; &nbsp; &nbsp; noteOn: {},<br \/>\r\n&nbsp; &nbsp; &nbsp; noteOff: {},<br \/>\r\n&nbsp; &nbsp; }<br \/>\r\n&nbsp; ],<br \/>\r\n};<br \/>\r\nfunction tick() {<br \/>\r\n&nbsp; if (!playing) {<br \/>\r\n&nbsp; &nbsp; return;<br \/>\r\n&nbsp; }<br \/>\r\n&nbsp; tape.tracks.forEach(function (track, trackNumber) {<br \/>\r\n&nbsp; &nbsp; if (typeof track.noteOn[step] !== \"undefined\") {<br \/>\r\n&nbsp; &nbsp; &nbsp; for (let note in track.noteOn[step]) {<br \/>\r\n&nbsp; &nbsp; &nbsp; &nbsp; getOutputDevice(trackNumber).playNote(note, track.outputChannel, {<br \/>\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; velocity: track.noteOn[step][note],<br \/>\r\n&nbsp; &nbsp; &nbsp; &nbsp; });<br \/>\r\n&nbsp; &nbsp; &nbsp; }<br \/>\r\n&nbsp; &nbsp; }<br \/>\r\n&nbsp; &nbsp; if (typeof track.noteOff[step] !== \"undefined\") {<br \/>\r\n&nbsp; &nbsp; &nbsp; track.noteOff[step].forEach(function (note) {<br \/>\r\n&nbsp; &nbsp; &nbsp; &nbsp; getOutputDevice(trackNumber).stopNote(note, track.outputChannel);<br \/>\r\n&nbsp; &nbsp; &nbsp; });<br \/>\r\n&nbsp; &nbsp; }<br \/>\r\n&nbsp; });<br \/>\r\n&nbsp; step++;<br \/>\r\n}<\/code><br \/>\r\n<br \/>\r\nTo summarize, once per step we iterate over every track in the \"tape\", and if there are any messages to send we do so. To determine how many times to call tick() in milliseconds, you use the formula \"60000 \/ (bpm * ppq)\". So for the above example, that'd be 23 milliseconds.<\/p>\r\n\r\n<p>You'd think that code like this would work:<\/p>\r\n\r\n<p><code>setTimeout(tick, 23);<\/code><\/p>\r\n\r\n<p>But setTimeout is extremely unreliable, especially as users change tabs and reallocate resources. To make things more consistent, I created a new Web Worker just for the timing code so that it runs in its own thread. Web Workers also have more consistent performance when the page doesn't have focus. It still ended up running a little fast, so I also kept track of the last call time and offset the next setTimeout by the difference. This is again simplified, but the timer Web Worker script looks something like this:<\/p>\r\n\r\n<p><code>var lastTick = 0;<br \/>\r\nvar ppq = 24;<br \/>\r\nvar bpm = 110;<br \/>\r\nvar tickRate = 60000 \/ (bpm * ppq); function tick() {<br \/>\r\n&nbsp; let now = performance.now();<br \/>\r\n&nbsp; if (lastTick === 0) {<br \/>\r\n&nbsp; &nbsp; lastTick = now;<br \/>\r\n&nbsp; }<br \/>\r\n&nbsp; postMessage({});<br \/>\r\n&nbsp; timeout = tickRate;<br \/>\r\n&nbsp; var offset = now - lastTick - tickRate;<br \/>\r\n&nbsp; timeout -= offset;<br \/>\r\n&nbsp; setTimeout(tick, timeout);<br \/>\r\n&nbsp; lastTick = now;<br \/>\r\n} tick();<\/code><\/p>\r\n\r\n<p>The browser uses&nbsp; the Web Workers messages like this:<\/p>\r\n\r\n<p><code>let timer = new Worker(\"timer.js\");<br \/>\r\ntimer.onmessage = () =&gt; {<br \/>\r\n&nbsp; tick();<br \/>\r\n}<\/code><\/p>\r\n\r\n<p>Hopefully if anyone tries something similar this helps - the BPM is very consistent now, although nothing in JavaScript is perfect.<\/p>\r\n\r\n<p>That's most of how playback works, recording is simply a matter of getting the current global \"step\" and adding new data to the tape where needed.<\/p>\r\n\r\n<p>Using steps instead of time makes changing the BPM simple since we just have to change how often tick() gets called. Steps also made implementing a metronome straightforward since I could just use the modulus operator:<br \/>\r\n<br \/>\r\n<code>if (step % (tape.ppq * tape.bpb) === 0) { \/\/ bpb -&gt; beats per bar<br \/>\r\n&nbsp; metronome_synth.triggerAttackRelease(\"C4\", 0.1, Tone.context.currentTime);<br \/>\r\n} else if (step % tape.ppq === 0) {<br \/>\r\n&nbsp; metronome_synth.triggerAttackRelease(\"C3\", 0.1, Tone.context.currentTime);<br \/>\r\n}<\/code><br \/>\r\nAnd quantization as well:<\/p>\r\n\r\n<p><code>let setStep = step; \/\/ The step I played a note on<br \/>\r\nlet&nbsp;multiple =&nbsp;tape.ppq \/ 2; \/\/ Halving our PPQ means snapping to 8th notes<br \/>\r\nlet newStep = setStep + multiple \/ 2;<br \/>\r\nnewStep = newStep - (newStep % multiple); \/\/ The quantized step<\/code><\/p>\r\n\r\n<p>These features made me glad I decided to live in the world of steps, even though time would have been easier earlier on.<\/p>\r\n\r\n<h2>Saving, loading, and migrating tapes<\/h2>\r\n\r\n<p>[talk about localForage, saving tape every .5s]<\/p>\r\n\r\n<p>[talk about saving and loading to json]<\/p>\r\n\r\n<p>[talk about migrating tape formats]<\/p>\r\n\r\n<p>[talk about undo\/redo]<\/p>\r\n\r\n<h2>Creating a complex user interface without libraries<\/h2>\r\n\r\n<p>[show gif of cassette tape interactions]<\/p>\r\n\r\n<p>[talk about having different render methods and debounce to improve performance]<\/p>\r\n\r\n<p>[talk about complexity of rendering timeline]<\/p>\r\n\r\n<p>[talk about CSS animations and spinning of cassette]<\/p>\r\n\r\n<p>[talk about some regret not using a library]<\/p>\r\n\r\n<h2>Making a keyboard based web app<\/h2>\r\n\r\n<p>[talk about why it's keyboard based]<\/p>\r\n\r\n<p>[show code examples of keyup\/keydown event with globals needed to handle multiple key presses]<\/p>\r\n\r\n<p>[talk about UX of keyboard, how adding unlimited tracks was tricky]<\/p>\r\n\r\n<h2>Exporting to a real .midi file<\/h2>\r\n\r\n<p>[talk about why .midi wasn't used in the first place]<\/p>\r\n\r\n<p>[talk about Jazz-MIDI, where other libraries lacked]<\/p>\r\n\r\n<p>[talk about why import is impossible]<\/p>\r\n\r\n<h2>Monitoring and recording audio<\/h2>\r\n\r\n<p>[talk about why monitoring is useful]<\/p>\r\n\r\n<p>[talk about MediaRecording API, issues with noise cancelling]<\/p>\r\n",
            "format": "full_html",
            "summary": ""
        }
    ],
    "field_tags": [
        {
            "target_type": "taxonomy_term",
            "target_uuid": "10efe6cc-fa0a-4066-afee-dcaf17e0d82d"
        },
        {
            "target_type": "taxonomy_term",
            "target_uuid": "23b07c20-ef0f-49f3-8dba-f3b1daa50c5e"
        },
        {
            "target_type": "taxonomy_term",
            "target_uuid": "40f89116-30f1-4ab4-90e1-78974ad74dda"
        }
    ]
}